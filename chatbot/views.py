# # import openai
# # from rest_framework.views import APIView
# # from rest_framework.response import Response
# # from rest_framework import status
# # from dotenv import load_dotenv
# # import os

# # # Load environment variables
# # load_dotenv()

# # # Set OpenAI API key from environment
# # openai.api_key = os.getenv("OPENAI_API_KEY")


# # class ChatBotAPIView(APIView):
# #     def post(self, request, *args, **kwargs):
# #         """
# #         Accepts a message from the user and returns a response generated by OpenAI
# #         """
# #         user_message = request.data.get('message', None)
# #         print("user_message", user_message)
# #         if not user_message:
# #             return Response({"error": "Message is required."}, status=status.HTTP_400_BAD_REQUEST)

# #         try:
# #             # Use the chat-based endpoint for GPT-3.5 Turbo or GPT-4
# #             response = openai.ChatCompletion.create(
# #                 model="gpt-4",  # or "gpt-4" for GPT-4
# #                 messages=[
# #                     {"role": "user", "content": user_message}
# #                 ]
# #             )

# #             # Extract the response text from the OpenAI response
# #             ai_response = response['choices'][0]['message']['content'].strip()
            
# #             return Response({"response": ai_response}, status=status.HTTP_200_OK)

# #         # except openai.error.OpenAIError as e:
# #         #     # Catch OpenAI-specific errors
# #         #     return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
# #         except Exception as e:
# #             # Catch any other errors
# #             return Response({"error": f"An error occurred: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
# from rest_framework.views import APIView
# from rest_framework.response import Response
# from rest_framework import status
# from dotenv import load_dotenv
# import os
# # import openai
# from openai import OpenAI
# # Load environment variables
# load_dotenv()

# # Set OpenAI API key
# # openai.api_key = os.getenv("OPENAI_API_KEY")

# # Initialize OpenAI client
# client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# class ChatBotAPIView(APIView):
#     def post(self, request, *args, **kwargs):
#         """
#         Accepts a message from the user and returns a response generated by OpenAI,
#         but only answers questions relevant to dogs, cats, and related topics.
#         """
#         user_message = request.data.get('message', None)
#         if not user_message:
#             return Response({"error": "Message is required."}, status=status.HTTP_400_BAD_REQUEST)

#         try:
           
#             # Define the system message to make the chatbot focus on dogs and cats
#             system_message = (
#                 "You are an expert cynologist and veterinarian specializing in dogs and cats. "
#                 "Your job is to provide helpful, accurate, and relevant information about dogs and cats only. "
#                 "You are not allowed to provide responses unrelated to dogs, cats, or any pets similar to them. "
#                 "Your answers should include guidance on care, training, adoption, health issues, finding lost pets, etc. "
#                 "Please be detailed and professional in your responses."
#             )

#             # Combine the system prompt with the user's message to ensure focus
#             conversation = [
#                 {"role": "system", "content": system_message},
#                 {"role": "user", "content": user_message}
#             ]

#             # Generate AI response
#             response = client.chat.completions.create(
#             # response = openai.ChatCompletion.create(
#                 model="gpt-4",  # or "gpt-3.5-turbo" depending on your need
#                 messages=conversation
#             )

#             # Extract the AI's response
#             ai_response = response['choices'][0]['message']['content'].strip()

#             # Return the AI's response as a JSON response
#             return Response({"response": ai_response}, status=status.HTTP_200_OK)

#         except Exception as e:
#             return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
# from rest_framework.views import APIView
# from rest_framework.response import Response
# from rest_framework import status
# from dotenv import load_dotenv
# import os
# import openai  # Import the correct OpenAI package
# from rest_framework.permissions import IsAuthenticatedOrReadOnly
# # Load environment variables
# load_dotenv()

# # Set OpenAI API key
# openai.api_key = os.getenv("OPENAI_API_KEY")

# class ChatBotAPIView(APIView):
#     permission_classes = [IsAuthenticatedOrReadOnly]
#     def post(self, request, *args, **kwargs):
#         """
#         Accepts a message from the user and returns a response generated by OpenAI,
#         but only answers questions relevant to dogs, cats, and related topics.
#         """
        
#         user_message = request.data.get('message', None)
#         print("user_message", user_message)
#         if not user_message:
#             return Response({"error": "Message is required."}, status=status.HTTP_400_BAD_REQUEST)

#         try:
#             # Define the system message to make the chatbot focus on dogs and cats
#             system_message = (
#                 "You are an expert cynologist and veterinarian specializing in dogs and cats. "
#                 "Your job is to provide helpful, accurate, and relevant information about dogs and cats only. "
#                 "You are not allowed to provide responses unrelated to dogs, cats, or any pets similar to them. "
#                 "Your answers should include guidance on care, training, adoption, health issues, finding lost pets, etc. "
#                 "Please be detailed and professional in your responses."
#             )

#             # Combine the system prompt with the user's message to ensure focus
#             conversation = [
#                 {"role": "system", "content": system_message},
#                 {"role": "user", "content": user_message}
#             ]

#             # Generate AI response using the new OpenAI client (chat completion)
#             response = openai.ChatCompletion.create(
#                 model="gpt-4",  # or "gpt-3.5-turbo" depending on your need
#                 messages=conversation
#             )

#             # Extract the AI's response
#             ai_response = response['choices'][0]['message']['content'].strip()

#             # Return the AI's response as a JSON response
#             return Response({"response": ai_response}, status=status.HTTP_200_OK)

#         except Exception as e:
#             # If there's an error, return the error message as a response
#             return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
# from rest_framework.views import APIView
# from rest_framework.response import Response
# from rest_framework import status
# from dotenv import load_dotenv
# import os
# import openai  # Import the OpenAI package

# # Load environment variables
# load_dotenv()

# # Set OpenAI API key
# openai.api_key = os.getenv("OPENAI_API_KEY")

# class ChatBotAPIView(APIView):
#     def post(self, request, *args, **kwargs):
#         """
#         Accepts a message from the user and returns a response generated by OpenAI,
#         but only answers questions relevant to dogs, cats, and related topics.
#         """
#         user_message = request.data.get('message', None)
#         if not user_message:
#             return Response({"error": "Message is required."}, status=status.HTTP_400_BAD_REQUEST)

#         try:
#             # Define the system message to make the chatbot focus on dogs and cats
#             system_message = (
#                 "You are an expert cynologist and veterinarian specializing in dogs and cats. "
#                 "Your job is to provide helpful, accurate, and relevant information about dogs and cats only. "
#                 "You are not allowed to provide responses unrelated to dogs, cats, or any pets similar to them. "
#                 "Your answers should include guidance on care, training, adoption, health issues, finding lost pets, etc. "
#                 "Please be detailed and professional in your responses."
#             )

#             # Combine the system prompt with the user's message to ensure focus
#             conversation = [
#                 {"role": "system", "content": system_message},
#                 {"role": "user", "content": user_message}
#             ]

#             # Print the conversation for debugging
#             print("Sending the following conversation to OpenAI:")
#             print(conversation)

#             # Generate AI response using the OpenAI chat completion API
#             response = openai.ChatCompletion.create(
#                 model="gpt-4",  # or "gpt-3.5-turbo" depending on your need
#                 messages=conversation
#             )

#             # Print the response from OpenAI for debugging
#             print("OpenAI response:")
#             print(response)

#             # Extract the AI's response
#             ai_response = response['choices'][0]['message']['content'].strip()

#             # Return the AI's response as a JSON response
#             return Response({"response": ai_response}, status=status.HTTP_200_OK)

#         except openai.error.OpenAIError as e:
#             # Catch OpenAI-specific errors and provide a response
#             return Response({"error": f"OpenAI API error: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

#         except Exception as e:
#             # Catch any other errors and log them
#             print(f"Error occurred: {str(e)}")  # Log the error for debugging
#             return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from dotenv import load_dotenv
import os
from openai import OpenAI

# Load environment variables
load_dotenv()

# Initialize OpenAI client
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

class ChatBotAPIView(APIView):
    def post(self, request, *args, **kwargs):
        """
        Accepts a message from the user and returns a response generated by OpenAI,
        but only answers questions relevant to dogs, cats, and related topics.
        """
        user_message = request.data.get('message', None)
        if not user_message:
            return Response({"error": "Message is required."}, status=status.HTTP_400_BAD_REQUEST)

        # Debugging: Print the incoming user message
        print(f"Received user message: {user_message}")

        try:
            # Define the system message to make the chatbot focus on dogs and cats
            system_message = (
                "You are an expert cynologist and veterinarian specializing in dogs and cats. "
                "Your job is to provide helpful, accurate, and relevant information about dogs and cats only. "
                "You are not allowed to provide responses unrelated to dogs, cats, or any pets similar to them. "
                "Your answers should include guidance on care, training, adoption, health issues, finding lost pets, etc. "
                "Focus on providing the essential information only. "
                "Avoid long explanations, and limit responses to a few sentences. "
                "No unnecessary elaboration or details. Only what's necessary to answer the user's question. "
                "If the question requires multiple steps, summarize the steps in short bullet points. "
                # "Please be detailed and professional in your responses."
                
            )

            # Combine the system prompt with the user's message to ensure focus
            conversation = [
                {"role": "system", "content": system_message},
                {"role": "user", "content": user_message}
            ]

            # Debugging: Print the conversation being sent to OpenAI
            print(f"Sending the following conversation to OpenAI: {conversation}")

            # Generate AI response
            response = client.chat.completions.create(
                model="gpt-4",  # You can use "gpt-3.5-turbo" if you prefer a smaller model
                messages=conversation
            )

            # Debugging: Print the raw response from OpenAI
            print(f"Raw response from OpenAI: {response}")

            # Extract the AI's response
            ai_response = response.choices[0].message.content.strip()

            # Debugging: Print the AI's response
            print(f"AI response: {ai_response}")

            # Return the AI's response as a JSON response
            return Response({"response": ai_response}, status=status.HTTP_200_OK)

        except Exception as e:
            # Debugging: Print the error message
            print(f"Error occurred: {str(e)}")
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

